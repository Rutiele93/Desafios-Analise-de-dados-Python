# -*- coding: utf-8 -*-
"""Desafio5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jHLB2jQ1QDwhej7RPvdebP-Uu7diisei
"""

!pip install sidetable
!pip install pandas-profiling==3.3.0
!pip install ydata-profiling

!pip install --upgrade numpy

import numpy as np
import pandas as pd

import seaborn as sns
import matplotlib.pyplot as plt

import sidetable
import missingno as msno
from ipywidgets import interact, widgets

from sklearn import datasets
from sklearn.preprocessing import scale, minmax_scale, power_transform

dados = pd.read_csv('Data - data.csv', sep = ",")
dados.info()
dados.describe()



dados_missing = (
  dados.isna().sum()
  .to_frame('missing_count')
  .join((dados.isna().sum() / dados.shape[0]).to_frame('missing_pct'))
  .sort_values('missing_count', ascending=False)
)

dados_missing.style.format('{:.2%}', subset=['missing_pct'])

dados[dados.isna().any(axis=1)]

dados[dados.CustomerID.isna()]

dados[dados.Description.isna()]

dados.drop(columns=['Description', 'CustomerID'])

# Filtrar as linhas onde UnitPrice é nulo ou menor ou igual a zero
preco_invalido = dados[(dados['UnitPrice'].isna()) | (dados['UnitPrice'] <= 0)]

# Exibir as linhas com valores inválidos
print("Linhas com UnitPrice nulo ou menor ou igual a zero:")
print(preco_invalido)

# Remover as observações com UnitPrice nulo ou menor ou igual a zero
dados_limpo = dados.drop(preco_invalido.index)

# Verificar se a remoção foi feita corretamente
print(f"Total de linhas após a remoção: {dados_limpo.shape[0]}")

# Passo 1: Filtrar linhas onde UnitPrice é nulo ou menor ou igual a zero
preco_invalido = dados[(dados['UnitPrice'].isna()) | (dados['UnitPrice'] <= 0)]
print("Linhas com UnitPrice nulo ou menor ou igual a zero:")
print(preco_invalido)

# Passo 2: Filtrar o dataset apenas com preços acima de zero
dados = dados[dados['UnitPrice'] > 0]
print(f"Total de linhas após remover preços inválidos: {dados.shape[0]}")

# Passo 3: Filtrar linhas onde Quantity é nulo ou menor ou igual a zero
quantidade_invalida = dados[(dados['Quantity'].isna()) | (dados['Quantity'] <= 0)]
print("Linhas com Quantity nulo ou menor ou igual a zero:")
print(quantidade_invalida)

# Passo 4: Filtrar o dataset apenas com quantidade acima de zero
dados = dados[dados['Quantity'] > 0]
print(f"Total de linhas após remover quantidades inválidas: {dados.shape[0]}")

# Passo 1: Verificar se existem linhas duplicadas
duplicatas = dados[dados.duplicated()]

# Exibir as linhas duplicadas, se existirem
print("Linhas duplicadas:")
print(duplicatas)

# Passo 2: Remover linhas duplicadas
dados = dados.drop_duplicates()

# Verificar o total de linhas após a remoção
print(f"Total de linhas após remover duplicatas: {dados.shape[0]}")

# Passo 1: Remover valores não numéricos e converter CustomerID para numérico
# O argumento errors='coerce' transforma entradas inválidas em NaN
dados['CustomerID'] = pd.to_numeric(dados['CustomerID'], errors='coerce')

# Agora, você pode verificar se há valores nulos após a conversão
print(f"Total de valores nulos em CustomerID após conversão: {dados['CustomerID'].isna().sum()}")

# Se houver valores nulos, decida como tratá-los (remover ou preencher)
# Aqui, estamos removendo linhas com CustomerID nulo
dados = dados.dropna(subset=['CustomerID'])

# Passo 2: Corrigir o tipo de dado do CustomerID para int
dados['CustomerID'] = dados['CustomerID'].astype(int)

# Passo 3: Corrigir o tipo de dado da InvoiceDate
dados['InvoiceDate'] = pd.to_datetime(dados['InvoiceDate'], format='%m/%d/%Y %H:%M', errors='coerce')

# Verifique os tipos de dados após as correções
print(dados.dtypes)

# Passo 1: Visualizar os outliers
# Usaremos um gráfico de dispersão para visualizar os dados
plt.figure(figsize=(12, 6))
plt.scatter(dados['Quantity'], dados['UnitPrice'], alpha=0.5)
plt.title('Scatter Plot de Quantidade vs. Preço Unitário')
plt.xlabel('Quantidade')
plt.ylabel('Preço Unitário')
plt.axhline(y=5000, color='r', linestyle='--', label='Preço Unitário > 5000')
plt.axvline(x=10000, color='g', linestyle='--', label='Quantidade > 10000')
plt.legend()
plt.show()

# Passo 2: Remover os outliers extremos
dados = dados[~((dados['Quantity'] > 10000) & (dados['UnitPrice'] > 5000))]

# Verifique o total de linhas após a remoção dos outliers
print(f"Total de linhas após remover outliers: {dados.shape[0]}")

# Criar uma nova coluna 'TotalPrice' calculando o preço total da compra
dados['TotalPrice'] = dados['Quantity'] * dados['UnitPrice']

# Verifique as primeiras linhas do DataFrame para confirmar a nova coluna
print(dados[['Quantity', 'UnitPrice', 'TotalPrice']].head())

# Calcular a data da última compra
ultima_data = dados['InvoiceDate'].max()

# Exibir a data da última compra
print(f"A última data de compra registrada é: {ultima_data}")

#Top 10 países com maior valor em vendas
# Agrupar o total de vendas por país e ordenar
top_countries = (dados.groupby('Country')['TotalPrice'].sum()
                 .sort_values(ascending=False)
                 .head(10))

# Plotar o gráfico de barras
plt.figure(figsize=(10, 6))
top_countries.plot(kind='bar', color='skyblue')
plt.title('Top 10 Países com Maior Valor em Vendas')
plt.xlabel('País')
plt.ylabel('Total de Vendas')
plt.xticks(rotation=45)
plt.show()

#Passo 2: Top 10 produtos mais vendidos
# Agrupar a quantidade vendida por produto e ordenar
top_products = (dados.groupby('Description')['Quantity'].sum()
                .sort_values(ascending=False)
                .head(10))

# Plotar o gráfico de barras
plt.figure(figsize=(10, 6))
top_products.plot(kind='bar', color='lightgreen')
plt.title('Top 10 Produtos Mais Vendidos')
plt.xlabel('Produto')
plt.ylabel('Quantidade Vendida')
plt.xticks(rotation=45)
plt.show()

#Passo 3: Valor de venda total por mês
# Extrair o mês e o ano da coluna InvoiceDate
dados['YearMonth'] = dados['InvoiceDate'].dt.to_period('M')

# Agrupar o valor de vendas por mês
monthly_sales = dados.groupby('YearMonth')['TotalPrice'].sum()

# Plotar o gráfico de linha
plt.figure(figsize=(12, 6))
monthly_sales.plot(kind='line', marker='o', color='purple')
plt.title('Valor de Venda Total por Mês')
plt.xlabel('Mês')
plt.ylabel('Total de Vendas')
plt.xticks(rotation=45)
plt.show()

#Passo 4: Valor de venda total por mês e por país (considerando apenas os top 10 países)
# Selecionar os top 10 países
top_10_countries = top_countries.index

# Filtrar os dados para conter apenas os top 10 países
dados_top_countries = dados[dados['Country'].isin(top_10_countries)]

# Agrupar o valor de vendas por mês e país
monthly_country_sales = dados_top_countries.groupby(['YearMonth', 'Country'])['TotalPrice'].sum().unstack()

# Plotar o gráfico
plt.figure(figsize=(14, 8))
monthly_country_sales.plot(kind='line', marker='o')
plt.title('Valor de Venda Total por Mês e por País (Top 10 Países)')
plt.xlabel('Mês')
plt.ylabel('Total de Vendas')
plt.xticks(rotation=45)
plt.legend(title='País')
plt.show()

#Passo 1: Agrupar os dados por cliente e pedido
# Agrupar os dados por cliente e pedido, somando o valor total do pedido
dados_clientes = dados.groupby(['CustomerID', 'InvoiceNo']).agg({
    'InvoiceDate': 'max',     # Última data para cada pedido
    'TotalPrice': 'sum'       # Total de cada pedido
}).reset_index()

#Passo 2: Calcular Recência (R), Frequência (F) e Valor Monetário (M)
# Calcular RFM para cada cliente
rfm = dados_clientes.groupby('CustomerID').agg({
    'InvoiceDate': lambda x: (ultima_data - x.max()).days,  # Recência (R)
    'InvoiceNo': 'nunique',                                 # Frequência (F)
    'TotalPrice': 'mean'                                    # Valor Monetário (M)
}).rename(columns={'InvoiceDate': 'Recency', 'InvoiceNo': 'Frequency', 'TotalPrice': 'MonetaryValue'})

# Exibir o resultado
print(rfm.head())

